// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: customisation.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_customisation_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_customisation_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_customisation_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_customisation_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_customisation_2eproto;
namespace proto {
class RuntimeOptions;
struct RuntimeOptionsDefaultTypeInternal;
extern RuntimeOptionsDefaultTypeInternal _RuntimeOptions_default_instance_;
class RuntimeOptions_EnvironmentVariablesEntry_DoNotUse;
struct RuntimeOptions_EnvironmentVariablesEntry_DoNotUseDefaultTypeInternal;
extern RuntimeOptions_EnvironmentVariablesEntry_DoNotUseDefaultTypeInternal _RuntimeOptions_EnvironmentVariablesEntry_DoNotUse_default_instance_;
class RuntimeOptions_PixelStreaming;
struct RuntimeOptions_PixelStreamingDefaultTypeInternal;
extern RuntimeOptions_PixelStreamingDefaultTypeInternal _RuntimeOptions_PixelStreaming_default_instance_;
class RuntimeOptions_PixelStreaming_WebRTC;
struct RuntimeOptions_PixelStreaming_WebRTCDefaultTypeInternal;
extern RuntimeOptions_PixelStreaming_WebRTCDefaultTypeInternal _RuntimeOptions_PixelStreaming_WebRTC_default_instance_;
class RuntimeOptions_Resolution;
struct RuntimeOptions_ResolutionDefaultTypeInternal;
extern RuntimeOptions_ResolutionDefaultTypeInternal _RuntimeOptions_Resolution_default_instance_;
class RuntimeOptions_VolumeMounts;
struct RuntimeOptions_VolumeMountsDefaultTypeInternal;
extern RuntimeOptions_VolumeMountsDefaultTypeInternal _RuntimeOptions_VolumeMounts_default_instance_;
class UpdateRuntimeOptionsRequest;
struct UpdateRuntimeOptionsRequestDefaultTypeInternal;
extern UpdateRuntimeOptionsRequestDefaultTypeInternal _UpdateRuntimeOptionsRequest_default_instance_;
class UpdateRuntimeOptionsResponse;
struct UpdateRuntimeOptionsResponseDefaultTypeInternal;
extern UpdateRuntimeOptionsResponseDefaultTypeInternal _UpdateRuntimeOptionsResponse_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::RuntimeOptions* Arena::CreateMaybeMessage<::proto::RuntimeOptions>(Arena*);
template<> ::proto::RuntimeOptions_EnvironmentVariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::proto::RuntimeOptions_EnvironmentVariablesEntry_DoNotUse>(Arena*);
template<> ::proto::RuntimeOptions_PixelStreaming* Arena::CreateMaybeMessage<::proto::RuntimeOptions_PixelStreaming>(Arena*);
template<> ::proto::RuntimeOptions_PixelStreaming_WebRTC* Arena::CreateMaybeMessage<::proto::RuntimeOptions_PixelStreaming_WebRTC>(Arena*);
template<> ::proto::RuntimeOptions_Resolution* Arena::CreateMaybeMessage<::proto::RuntimeOptions_Resolution>(Arena*);
template<> ::proto::RuntimeOptions_VolumeMounts* Arena::CreateMaybeMessage<::proto::RuntimeOptions_VolumeMounts>(Arena*);
template<> ::proto::UpdateRuntimeOptionsRequest* Arena::CreateMaybeMessage<::proto::UpdateRuntimeOptionsRequest>(Arena*);
template<> ::proto::UpdateRuntimeOptionsResponse* Arena::CreateMaybeMessage<::proto::UpdateRuntimeOptionsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class UpdateRuntimeOptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.UpdateRuntimeOptionsRequest) */ {
 public:
  inline UpdateRuntimeOptionsRequest() : UpdateRuntimeOptionsRequest(nullptr) {}
  ~UpdateRuntimeOptionsRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRuntimeOptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRuntimeOptionsRequest(const UpdateRuntimeOptionsRequest& from);
  UpdateRuntimeOptionsRequest(UpdateRuntimeOptionsRequest&& from) noexcept
    : UpdateRuntimeOptionsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRuntimeOptionsRequest& operator=(const UpdateRuntimeOptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRuntimeOptionsRequest& operator=(UpdateRuntimeOptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRuntimeOptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRuntimeOptionsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRuntimeOptionsRequest*>(
               &_UpdateRuntimeOptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UpdateRuntimeOptionsRequest& a, UpdateRuntimeOptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRuntimeOptionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRuntimeOptionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRuntimeOptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRuntimeOptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRuntimeOptionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRuntimeOptionsRequest& from) {
    UpdateRuntimeOptionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRuntimeOptionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UpdateRuntimeOptionsRequest";
  }
  protected:
  explicit UpdateRuntimeOptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceFieldNumber = 1,
    kPluginOptionsFieldNumber = 2,
    kRuntimeOptionsFieldNumber = 3,
  };
  // string instance = 1;
  void clear_instance();
  const std::string& instance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance();
  PROTOBUF_NODISCARD std::string* release_instance();
  void set_allocated_instance(std::string* instance);
  private:
  const std::string& _internal_instance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance(const std::string& value);
  std::string* _internal_mutable_instance();
  public:

  // string pluginOptions = 2;
  void clear_pluginoptions();
  const std::string& pluginoptions() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pluginoptions(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pluginoptions();
  PROTOBUF_NODISCARD std::string* release_pluginoptions();
  void set_allocated_pluginoptions(std::string* pluginoptions);
  private:
  const std::string& _internal_pluginoptions() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pluginoptions(const std::string& value);
  std::string* _internal_mutable_pluginoptions();
  public:

  // .proto.RuntimeOptions runtimeOptions = 3;
  bool has_runtimeoptions() const;
  private:
  bool _internal_has_runtimeoptions() const;
  public:
  void clear_runtimeoptions();
  const ::proto::RuntimeOptions& runtimeoptions() const;
  PROTOBUF_NODISCARD ::proto::RuntimeOptions* release_runtimeoptions();
  ::proto::RuntimeOptions* mutable_runtimeoptions();
  void set_allocated_runtimeoptions(::proto::RuntimeOptions* runtimeoptions);
  private:
  const ::proto::RuntimeOptions& _internal_runtimeoptions() const;
  ::proto::RuntimeOptions* _internal_mutable_runtimeoptions();
  public:
  void unsafe_arena_set_allocated_runtimeoptions(
      ::proto::RuntimeOptions* runtimeoptions);
  ::proto::RuntimeOptions* unsafe_arena_release_runtimeoptions();

  // @@protoc_insertion_point(class_scope:proto.UpdateRuntimeOptionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pluginoptions_;
    ::proto::RuntimeOptions* runtimeoptions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_customisation_2eproto;
};
// -------------------------------------------------------------------

class UpdateRuntimeOptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.UpdateRuntimeOptionsResponse) */ {
 public:
  inline UpdateRuntimeOptionsResponse() : UpdateRuntimeOptionsResponse(nullptr) {}
  ~UpdateRuntimeOptionsResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateRuntimeOptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRuntimeOptionsResponse(const UpdateRuntimeOptionsResponse& from);
  UpdateRuntimeOptionsResponse(UpdateRuntimeOptionsResponse&& from) noexcept
    : UpdateRuntimeOptionsResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRuntimeOptionsResponse& operator=(const UpdateRuntimeOptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRuntimeOptionsResponse& operator=(UpdateRuntimeOptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRuntimeOptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRuntimeOptionsResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRuntimeOptionsResponse*>(
               &_UpdateRuntimeOptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UpdateRuntimeOptionsResponse& a, UpdateRuntimeOptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRuntimeOptionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRuntimeOptionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRuntimeOptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRuntimeOptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRuntimeOptionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRuntimeOptionsResponse& from) {
    UpdateRuntimeOptionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRuntimeOptionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.UpdateRuntimeOptionsResponse";
  }
  protected:
  explicit UpdateRuntimeOptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuntimeOptionsFieldNumber = 1,
  };
  // .proto.RuntimeOptions runtimeOptions = 1;
  bool has_runtimeoptions() const;
  private:
  bool _internal_has_runtimeoptions() const;
  public:
  void clear_runtimeoptions();
  const ::proto::RuntimeOptions& runtimeoptions() const;
  PROTOBUF_NODISCARD ::proto::RuntimeOptions* release_runtimeoptions();
  ::proto::RuntimeOptions* mutable_runtimeoptions();
  void set_allocated_runtimeoptions(::proto::RuntimeOptions* runtimeoptions);
  private:
  const ::proto::RuntimeOptions& _internal_runtimeoptions() const;
  ::proto::RuntimeOptions* _internal_mutable_runtimeoptions();
  public:
  void unsafe_arena_set_allocated_runtimeoptions(
      ::proto::RuntimeOptions* runtimeoptions);
  ::proto::RuntimeOptions* unsafe_arena_release_runtimeoptions();

  // @@protoc_insertion_point(class_scope:proto.UpdateRuntimeOptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::RuntimeOptions* runtimeoptions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_customisation_2eproto;
};
// -------------------------------------------------------------------

class RuntimeOptions_Resolution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RuntimeOptions.Resolution) */ {
 public:
  inline RuntimeOptions_Resolution() : RuntimeOptions_Resolution(nullptr) {}
  ~RuntimeOptions_Resolution() override;
  explicit PROTOBUF_CONSTEXPR RuntimeOptions_Resolution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeOptions_Resolution(const RuntimeOptions_Resolution& from);
  RuntimeOptions_Resolution(RuntimeOptions_Resolution&& from) noexcept
    : RuntimeOptions_Resolution() {
    *this = ::std::move(from);
  }

  inline RuntimeOptions_Resolution& operator=(const RuntimeOptions_Resolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeOptions_Resolution& operator=(RuntimeOptions_Resolution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeOptions_Resolution& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeOptions_Resolution* internal_default_instance() {
    return reinterpret_cast<const RuntimeOptions_Resolution*>(
               &_RuntimeOptions_Resolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RuntimeOptions_Resolution& a, RuntimeOptions_Resolution& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeOptions_Resolution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeOptions_Resolution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuntimeOptions_Resolution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuntimeOptions_Resolution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeOptions_Resolution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RuntimeOptions_Resolution& from) {
    RuntimeOptions_Resolution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeOptions_Resolution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RuntimeOptions.Resolution";
  }
  protected:
  explicit RuntimeOptions_Resolution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RuntimeOptions.Resolution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_customisation_2eproto;
};
// -------------------------------------------------------------------

class RuntimeOptions_PixelStreaming_WebRTC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RuntimeOptions.PixelStreaming.WebRTC) */ {
 public:
  inline RuntimeOptions_PixelStreaming_WebRTC() : RuntimeOptions_PixelStreaming_WebRTC(nullptr) {}
  ~RuntimeOptions_PixelStreaming_WebRTC() override;
  explicit PROTOBUF_CONSTEXPR RuntimeOptions_PixelStreaming_WebRTC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeOptions_PixelStreaming_WebRTC(const RuntimeOptions_PixelStreaming_WebRTC& from);
  RuntimeOptions_PixelStreaming_WebRTC(RuntimeOptions_PixelStreaming_WebRTC&& from) noexcept
    : RuntimeOptions_PixelStreaming_WebRTC() {
    *this = ::std::move(from);
  }

  inline RuntimeOptions_PixelStreaming_WebRTC& operator=(const RuntimeOptions_PixelStreaming_WebRTC& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeOptions_PixelStreaming_WebRTC& operator=(RuntimeOptions_PixelStreaming_WebRTC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeOptions_PixelStreaming_WebRTC& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeOptions_PixelStreaming_WebRTC* internal_default_instance() {
    return reinterpret_cast<const RuntimeOptions_PixelStreaming_WebRTC*>(
               &_RuntimeOptions_PixelStreaming_WebRTC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RuntimeOptions_PixelStreaming_WebRTC& a, RuntimeOptions_PixelStreaming_WebRTC& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeOptions_PixelStreaming_WebRTC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeOptions_PixelStreaming_WebRTC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuntimeOptions_PixelStreaming_WebRTC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuntimeOptions_PixelStreaming_WebRTC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeOptions_PixelStreaming_WebRTC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RuntimeOptions_PixelStreaming_WebRTC& from) {
    RuntimeOptions_PixelStreaming_WebRTC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeOptions_PixelStreaming_WebRTC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RuntimeOptions.PixelStreaming.WebRTC";
  }
  protected:
  explicit RuntimeOptions_PixelStreaming_WebRTC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxFPSFieldNumber = 1,
  };
  // int64 maxFPS = 1;
  void clear_maxfps();
  int64_t maxfps() const;
  void set_maxfps(int64_t value);
  private:
  int64_t _internal_maxfps() const;
  void _internal_set_maxfps(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RuntimeOptions.PixelStreaming.WebRTC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t maxfps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_customisation_2eproto;
};
// -------------------------------------------------------------------

class RuntimeOptions_PixelStreaming final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RuntimeOptions.PixelStreaming) */ {
 public:
  inline RuntimeOptions_PixelStreaming() : RuntimeOptions_PixelStreaming(nullptr) {}
  ~RuntimeOptions_PixelStreaming() override;
  explicit PROTOBUF_CONSTEXPR RuntimeOptions_PixelStreaming(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeOptions_PixelStreaming(const RuntimeOptions_PixelStreaming& from);
  RuntimeOptions_PixelStreaming(RuntimeOptions_PixelStreaming&& from) noexcept
    : RuntimeOptions_PixelStreaming() {
    *this = ::std::move(from);
  }

  inline RuntimeOptions_PixelStreaming& operator=(const RuntimeOptions_PixelStreaming& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeOptions_PixelStreaming& operator=(RuntimeOptions_PixelStreaming&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeOptions_PixelStreaming& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeOptions_PixelStreaming* internal_default_instance() {
    return reinterpret_cast<const RuntimeOptions_PixelStreaming*>(
               &_RuntimeOptions_PixelStreaming_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RuntimeOptions_PixelStreaming& a, RuntimeOptions_PixelStreaming& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeOptions_PixelStreaming* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeOptions_PixelStreaming* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuntimeOptions_PixelStreaming* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuntimeOptions_PixelStreaming>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeOptions_PixelStreaming& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RuntimeOptions_PixelStreaming& from) {
    RuntimeOptions_PixelStreaming::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeOptions_PixelStreaming* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RuntimeOptions.PixelStreaming";
  }
  protected:
  explicit RuntimeOptions_PixelStreaming(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RuntimeOptions_PixelStreaming_WebRTC WebRTC;

  // accessors -------------------------------------------------------

  enum : int {
    kWebRTCFieldNumber = 1,
  };
  // .proto.RuntimeOptions.PixelStreaming.WebRTC webRTC = 1;
  bool has_webrtc() const;
  private:
  bool _internal_has_webrtc() const;
  public:
  void clear_webrtc();
  const ::proto::RuntimeOptions_PixelStreaming_WebRTC& webrtc() const;
  PROTOBUF_NODISCARD ::proto::RuntimeOptions_PixelStreaming_WebRTC* release_webrtc();
  ::proto::RuntimeOptions_PixelStreaming_WebRTC* mutable_webrtc();
  void set_allocated_webrtc(::proto::RuntimeOptions_PixelStreaming_WebRTC* webrtc);
  private:
  const ::proto::RuntimeOptions_PixelStreaming_WebRTC& _internal_webrtc() const;
  ::proto::RuntimeOptions_PixelStreaming_WebRTC* _internal_mutable_webrtc();
  public:
  void unsafe_arena_set_allocated_webrtc(
      ::proto::RuntimeOptions_PixelStreaming_WebRTC* webrtc);
  ::proto::RuntimeOptions_PixelStreaming_WebRTC* unsafe_arena_release_webrtc();

  // @@protoc_insertion_point(class_scope:proto.RuntimeOptions.PixelStreaming)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::proto::RuntimeOptions_PixelStreaming_WebRTC* webrtc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_customisation_2eproto;
};
// -------------------------------------------------------------------

class RuntimeOptions_EnvironmentVariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RuntimeOptions_EnvironmentVariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RuntimeOptions_EnvironmentVariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RuntimeOptions_EnvironmentVariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RuntimeOptions_EnvironmentVariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RuntimeOptions_EnvironmentVariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RuntimeOptions_EnvironmentVariablesEntry_DoNotUse& other);
  static const RuntimeOptions_EnvironmentVariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RuntimeOptions_EnvironmentVariablesEntry_DoNotUse*>(&_RuntimeOptions_EnvironmentVariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "proto.RuntimeOptions.EnvironmentVariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "proto.RuntimeOptions.EnvironmentVariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_customisation_2eproto;
};

// -------------------------------------------------------------------

class RuntimeOptions_VolumeMounts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RuntimeOptions.VolumeMounts) */ {
 public:
  inline RuntimeOptions_VolumeMounts() : RuntimeOptions_VolumeMounts(nullptr) {}
  ~RuntimeOptions_VolumeMounts() override;
  explicit PROTOBUF_CONSTEXPR RuntimeOptions_VolumeMounts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeOptions_VolumeMounts(const RuntimeOptions_VolumeMounts& from);
  RuntimeOptions_VolumeMounts(RuntimeOptions_VolumeMounts&& from) noexcept
    : RuntimeOptions_VolumeMounts() {
    *this = ::std::move(from);
  }

  inline RuntimeOptions_VolumeMounts& operator=(const RuntimeOptions_VolumeMounts& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeOptions_VolumeMounts& operator=(RuntimeOptions_VolumeMounts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeOptions_VolumeMounts& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeOptions_VolumeMounts* internal_default_instance() {
    return reinterpret_cast<const RuntimeOptions_VolumeMounts*>(
               &_RuntimeOptions_VolumeMounts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RuntimeOptions_VolumeMounts& a, RuntimeOptions_VolumeMounts& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeOptions_VolumeMounts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeOptions_VolumeMounts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuntimeOptions_VolumeMounts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuntimeOptions_VolumeMounts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeOptions_VolumeMounts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RuntimeOptions_VolumeMounts& from) {
    RuntimeOptions_VolumeMounts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeOptions_VolumeMounts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RuntimeOptions.VolumeMounts";
  }
  protected:
  explicit RuntimeOptions_VolumeMounts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMountPathFieldNumber = 2,
    kReadOnlyFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string mountPath = 2;
  void clear_mountpath();
  const std::string& mountpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mountpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mountpath();
  PROTOBUF_NODISCARD std::string* release_mountpath();
  void set_allocated_mountpath(std::string* mountpath);
  private:
  const std::string& _internal_mountpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mountpath(const std::string& value);
  std::string* _internal_mutable_mountpath();
  public:

  // bool readOnly = 3;
  void clear_readonly();
  bool readonly() const;
  void set_readonly(bool value);
  private:
  bool _internal_readonly() const;
  void _internal_set_readonly(bool value);
  public:

  // @@protoc_insertion_point(class_scope:proto.RuntimeOptions.VolumeMounts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mountpath_;
    bool readonly_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_customisation_2eproto;
};
// -------------------------------------------------------------------

class RuntimeOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.RuntimeOptions) */ {
 public:
  inline RuntimeOptions() : RuntimeOptions(nullptr) {}
  ~RuntimeOptions() override;
  explicit PROTOBUF_CONSTEXPR RuntimeOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeOptions(const RuntimeOptions& from);
  RuntimeOptions(RuntimeOptions&& from) noexcept
    : RuntimeOptions() {
    *this = ::std::move(from);
  }

  inline RuntimeOptions& operator=(const RuntimeOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeOptions& operator=(RuntimeOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeOptions* internal_default_instance() {
    return reinterpret_cast<const RuntimeOptions*>(
               &_RuntimeOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RuntimeOptions& a, RuntimeOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuntimeOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuntimeOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RuntimeOptions& from) {
    RuntimeOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.RuntimeOptions";
  }
  protected:
  explicit RuntimeOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RuntimeOptions_Resolution Resolution;
  typedef RuntimeOptions_PixelStreaming PixelStreaming;
  typedef RuntimeOptions_VolumeMounts VolumeMounts;

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kEnvironmentVariablesFieldNumber = 3,
    kVolumeMountsFieldNumber = 4,
    kResolutionFieldNumber = 1,
    kPixelStreamingFieldNumber = 5,
  };
  // repeated string args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // map<string, string> environmentVariables = 3;
  int environmentvariables_size() const;
  private:
  int _internal_environmentvariables_size() const;
  public:
  void clear_environmentvariables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_environmentvariables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_environmentvariables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      environmentvariables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_environmentvariables();

  // repeated .proto.RuntimeOptions.VolumeMounts volumeMounts = 4;
  int volumemounts_size() const;
  private:
  int _internal_volumemounts_size() const;
  public:
  void clear_volumemounts();
  ::proto::RuntimeOptions_VolumeMounts* mutable_volumemounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RuntimeOptions_VolumeMounts >*
      mutable_volumemounts();
  private:
  const ::proto::RuntimeOptions_VolumeMounts& _internal_volumemounts(int index) const;
  ::proto::RuntimeOptions_VolumeMounts* _internal_add_volumemounts();
  public:
  const ::proto::RuntimeOptions_VolumeMounts& volumemounts(int index) const;
  ::proto::RuntimeOptions_VolumeMounts* add_volumemounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RuntimeOptions_VolumeMounts >&
      volumemounts() const;

  // .proto.RuntimeOptions.Resolution resolution = 1;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  const ::proto::RuntimeOptions_Resolution& resolution() const;
  PROTOBUF_NODISCARD ::proto::RuntimeOptions_Resolution* release_resolution();
  ::proto::RuntimeOptions_Resolution* mutable_resolution();
  void set_allocated_resolution(::proto::RuntimeOptions_Resolution* resolution);
  private:
  const ::proto::RuntimeOptions_Resolution& _internal_resolution() const;
  ::proto::RuntimeOptions_Resolution* _internal_mutable_resolution();
  public:
  void unsafe_arena_set_allocated_resolution(
      ::proto::RuntimeOptions_Resolution* resolution);
  ::proto::RuntimeOptions_Resolution* unsafe_arena_release_resolution();

  // .proto.RuntimeOptions.PixelStreaming pixelStreaming = 5;
  bool has_pixelstreaming() const;
  private:
  bool _internal_has_pixelstreaming() const;
  public:
  void clear_pixelstreaming();
  const ::proto::RuntimeOptions_PixelStreaming& pixelstreaming() const;
  PROTOBUF_NODISCARD ::proto::RuntimeOptions_PixelStreaming* release_pixelstreaming();
  ::proto::RuntimeOptions_PixelStreaming* mutable_pixelstreaming();
  void set_allocated_pixelstreaming(::proto::RuntimeOptions_PixelStreaming* pixelstreaming);
  private:
  const ::proto::RuntimeOptions_PixelStreaming& _internal_pixelstreaming() const;
  ::proto::RuntimeOptions_PixelStreaming* _internal_mutable_pixelstreaming();
  public:
  void unsafe_arena_set_allocated_pixelstreaming(
      ::proto::RuntimeOptions_PixelStreaming* pixelstreaming);
  ::proto::RuntimeOptions_PixelStreaming* unsafe_arena_release_pixelstreaming();

  // @@protoc_insertion_point(class_scope:proto.RuntimeOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RuntimeOptions_EnvironmentVariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> environmentvariables_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RuntimeOptions_VolumeMounts > volumemounts_;
    ::proto::RuntimeOptions_Resolution* resolution_;
    ::proto::RuntimeOptions_PixelStreaming* pixelstreaming_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_customisation_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UpdateRuntimeOptionsRequest

// string instance = 1;
inline void UpdateRuntimeOptionsRequest::clear_instance() {
  _impl_.instance_.ClearToEmpty();
}
inline const std::string& UpdateRuntimeOptionsRequest::instance() const {
  // @@protoc_insertion_point(field_get:proto.UpdateRuntimeOptionsRequest.instance)
  return _internal_instance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRuntimeOptionsRequest::set_instance(ArgT0&& arg0, ArgT... args) {
 
 _impl_.instance_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.UpdateRuntimeOptionsRequest.instance)
}
inline std::string* UpdateRuntimeOptionsRequest::mutable_instance() {
  std::string* _s = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:proto.UpdateRuntimeOptionsRequest.instance)
  return _s;
}
inline const std::string& UpdateRuntimeOptionsRequest::_internal_instance() const {
  return _impl_.instance_.Get();
}
inline void UpdateRuntimeOptionsRequest::_internal_set_instance(const std::string& value) {
  
  _impl_.instance_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRuntimeOptionsRequest::_internal_mutable_instance() {
  
  return _impl_.instance_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRuntimeOptionsRequest::release_instance() {
  // @@protoc_insertion_point(field_release:proto.UpdateRuntimeOptionsRequest.instance)
  return _impl_.instance_.Release();
}
inline void UpdateRuntimeOptionsRequest::set_allocated_instance(std::string* instance) {
  if (instance != nullptr) {
    
  } else {
    
  }
  _impl_.instance_.SetAllocated(instance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.instance_.IsDefault()) {
    _impl_.instance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.UpdateRuntimeOptionsRequest.instance)
}

// string pluginOptions = 2;
inline void UpdateRuntimeOptionsRequest::clear_pluginoptions() {
  _impl_.pluginoptions_.ClearToEmpty();
}
inline const std::string& UpdateRuntimeOptionsRequest::pluginoptions() const {
  // @@protoc_insertion_point(field_get:proto.UpdateRuntimeOptionsRequest.pluginOptions)
  return _internal_pluginoptions();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRuntimeOptionsRequest::set_pluginoptions(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pluginoptions_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.UpdateRuntimeOptionsRequest.pluginOptions)
}
inline std::string* UpdateRuntimeOptionsRequest::mutable_pluginoptions() {
  std::string* _s = _internal_mutable_pluginoptions();
  // @@protoc_insertion_point(field_mutable:proto.UpdateRuntimeOptionsRequest.pluginOptions)
  return _s;
}
inline const std::string& UpdateRuntimeOptionsRequest::_internal_pluginoptions() const {
  return _impl_.pluginoptions_.Get();
}
inline void UpdateRuntimeOptionsRequest::_internal_set_pluginoptions(const std::string& value) {
  
  _impl_.pluginoptions_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRuntimeOptionsRequest::_internal_mutable_pluginoptions() {
  
  return _impl_.pluginoptions_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRuntimeOptionsRequest::release_pluginoptions() {
  // @@protoc_insertion_point(field_release:proto.UpdateRuntimeOptionsRequest.pluginOptions)
  return _impl_.pluginoptions_.Release();
}
inline void UpdateRuntimeOptionsRequest::set_allocated_pluginoptions(std::string* pluginoptions) {
  if (pluginoptions != nullptr) {
    
  } else {
    
  }
  _impl_.pluginoptions_.SetAllocated(pluginoptions, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pluginoptions_.IsDefault()) {
    _impl_.pluginoptions_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.UpdateRuntimeOptionsRequest.pluginOptions)
}

// .proto.RuntimeOptions runtimeOptions = 3;
inline bool UpdateRuntimeOptionsRequest::_internal_has_runtimeoptions() const {
  return this != internal_default_instance() && _impl_.runtimeoptions_ != nullptr;
}
inline bool UpdateRuntimeOptionsRequest::has_runtimeoptions() const {
  return _internal_has_runtimeoptions();
}
inline void UpdateRuntimeOptionsRequest::clear_runtimeoptions() {
  if (GetArenaForAllocation() == nullptr && _impl_.runtimeoptions_ != nullptr) {
    delete _impl_.runtimeoptions_;
  }
  _impl_.runtimeoptions_ = nullptr;
}
inline const ::proto::RuntimeOptions& UpdateRuntimeOptionsRequest::_internal_runtimeoptions() const {
  const ::proto::RuntimeOptions* p = _impl_.runtimeoptions_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RuntimeOptions&>(
      ::proto::_RuntimeOptions_default_instance_);
}
inline const ::proto::RuntimeOptions& UpdateRuntimeOptionsRequest::runtimeoptions() const {
  // @@protoc_insertion_point(field_get:proto.UpdateRuntimeOptionsRequest.runtimeOptions)
  return _internal_runtimeoptions();
}
inline void UpdateRuntimeOptionsRequest::unsafe_arena_set_allocated_runtimeoptions(
    ::proto::RuntimeOptions* runtimeoptions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.runtimeoptions_);
  }
  _impl_.runtimeoptions_ = runtimeoptions;
  if (runtimeoptions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.UpdateRuntimeOptionsRequest.runtimeOptions)
}
inline ::proto::RuntimeOptions* UpdateRuntimeOptionsRequest::release_runtimeoptions() {
  
  ::proto::RuntimeOptions* temp = _impl_.runtimeoptions_;
  _impl_.runtimeoptions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RuntimeOptions* UpdateRuntimeOptionsRequest::unsafe_arena_release_runtimeoptions() {
  // @@protoc_insertion_point(field_release:proto.UpdateRuntimeOptionsRequest.runtimeOptions)
  
  ::proto::RuntimeOptions* temp = _impl_.runtimeoptions_;
  _impl_.runtimeoptions_ = nullptr;
  return temp;
}
inline ::proto::RuntimeOptions* UpdateRuntimeOptionsRequest::_internal_mutable_runtimeoptions() {
  
  if (_impl_.runtimeoptions_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RuntimeOptions>(GetArenaForAllocation());
    _impl_.runtimeoptions_ = p;
  }
  return _impl_.runtimeoptions_;
}
inline ::proto::RuntimeOptions* UpdateRuntimeOptionsRequest::mutable_runtimeoptions() {
  ::proto::RuntimeOptions* _msg = _internal_mutable_runtimeoptions();
  // @@protoc_insertion_point(field_mutable:proto.UpdateRuntimeOptionsRequest.runtimeOptions)
  return _msg;
}
inline void UpdateRuntimeOptionsRequest::set_allocated_runtimeoptions(::proto::RuntimeOptions* runtimeoptions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.runtimeoptions_;
  }
  if (runtimeoptions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(runtimeoptions);
    if (message_arena != submessage_arena) {
      runtimeoptions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtimeoptions, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.runtimeoptions_ = runtimeoptions;
  // @@protoc_insertion_point(field_set_allocated:proto.UpdateRuntimeOptionsRequest.runtimeOptions)
}

// -------------------------------------------------------------------

// UpdateRuntimeOptionsResponse

// .proto.RuntimeOptions runtimeOptions = 1;
inline bool UpdateRuntimeOptionsResponse::_internal_has_runtimeoptions() const {
  return this != internal_default_instance() && _impl_.runtimeoptions_ != nullptr;
}
inline bool UpdateRuntimeOptionsResponse::has_runtimeoptions() const {
  return _internal_has_runtimeoptions();
}
inline void UpdateRuntimeOptionsResponse::clear_runtimeoptions() {
  if (GetArenaForAllocation() == nullptr && _impl_.runtimeoptions_ != nullptr) {
    delete _impl_.runtimeoptions_;
  }
  _impl_.runtimeoptions_ = nullptr;
}
inline const ::proto::RuntimeOptions& UpdateRuntimeOptionsResponse::_internal_runtimeoptions() const {
  const ::proto::RuntimeOptions* p = _impl_.runtimeoptions_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RuntimeOptions&>(
      ::proto::_RuntimeOptions_default_instance_);
}
inline const ::proto::RuntimeOptions& UpdateRuntimeOptionsResponse::runtimeoptions() const {
  // @@protoc_insertion_point(field_get:proto.UpdateRuntimeOptionsResponse.runtimeOptions)
  return _internal_runtimeoptions();
}
inline void UpdateRuntimeOptionsResponse::unsafe_arena_set_allocated_runtimeoptions(
    ::proto::RuntimeOptions* runtimeoptions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.runtimeoptions_);
  }
  _impl_.runtimeoptions_ = runtimeoptions;
  if (runtimeoptions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.UpdateRuntimeOptionsResponse.runtimeOptions)
}
inline ::proto::RuntimeOptions* UpdateRuntimeOptionsResponse::release_runtimeoptions() {
  
  ::proto::RuntimeOptions* temp = _impl_.runtimeoptions_;
  _impl_.runtimeoptions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RuntimeOptions* UpdateRuntimeOptionsResponse::unsafe_arena_release_runtimeoptions() {
  // @@protoc_insertion_point(field_release:proto.UpdateRuntimeOptionsResponse.runtimeOptions)
  
  ::proto::RuntimeOptions* temp = _impl_.runtimeoptions_;
  _impl_.runtimeoptions_ = nullptr;
  return temp;
}
inline ::proto::RuntimeOptions* UpdateRuntimeOptionsResponse::_internal_mutable_runtimeoptions() {
  
  if (_impl_.runtimeoptions_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RuntimeOptions>(GetArenaForAllocation());
    _impl_.runtimeoptions_ = p;
  }
  return _impl_.runtimeoptions_;
}
inline ::proto::RuntimeOptions* UpdateRuntimeOptionsResponse::mutable_runtimeoptions() {
  ::proto::RuntimeOptions* _msg = _internal_mutable_runtimeoptions();
  // @@protoc_insertion_point(field_mutable:proto.UpdateRuntimeOptionsResponse.runtimeOptions)
  return _msg;
}
inline void UpdateRuntimeOptionsResponse::set_allocated_runtimeoptions(::proto::RuntimeOptions* runtimeoptions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.runtimeoptions_;
  }
  if (runtimeoptions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(runtimeoptions);
    if (message_arena != submessage_arena) {
      runtimeoptions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtimeoptions, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.runtimeoptions_ = runtimeoptions;
  // @@protoc_insertion_point(field_set_allocated:proto.UpdateRuntimeOptionsResponse.runtimeOptions)
}

// -------------------------------------------------------------------

// RuntimeOptions_Resolution

// int32 x = 1;
inline void RuntimeOptions_Resolution::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t RuntimeOptions_Resolution::_internal_x() const {
  return _impl_.x_;
}
inline int32_t RuntimeOptions_Resolution::x() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.Resolution.x)
  return _internal_x();
}
inline void RuntimeOptions_Resolution::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void RuntimeOptions_Resolution::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:proto.RuntimeOptions.Resolution.x)
}

// int32 y = 2;
inline void RuntimeOptions_Resolution::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t RuntimeOptions_Resolution::_internal_y() const {
  return _impl_.y_;
}
inline int32_t RuntimeOptions_Resolution::y() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.Resolution.y)
  return _internal_y();
}
inline void RuntimeOptions_Resolution::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void RuntimeOptions_Resolution::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:proto.RuntimeOptions.Resolution.y)
}

// -------------------------------------------------------------------

// RuntimeOptions_PixelStreaming_WebRTC

// int64 maxFPS = 1;
inline void RuntimeOptions_PixelStreaming_WebRTC::clear_maxfps() {
  _impl_.maxfps_ = int64_t{0};
}
inline int64_t RuntimeOptions_PixelStreaming_WebRTC::_internal_maxfps() const {
  return _impl_.maxfps_;
}
inline int64_t RuntimeOptions_PixelStreaming_WebRTC::maxfps() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.PixelStreaming.WebRTC.maxFPS)
  return _internal_maxfps();
}
inline void RuntimeOptions_PixelStreaming_WebRTC::_internal_set_maxfps(int64_t value) {
  
  _impl_.maxfps_ = value;
}
inline void RuntimeOptions_PixelStreaming_WebRTC::set_maxfps(int64_t value) {
  _internal_set_maxfps(value);
  // @@protoc_insertion_point(field_set:proto.RuntimeOptions.PixelStreaming.WebRTC.maxFPS)
}

// -------------------------------------------------------------------

// RuntimeOptions_PixelStreaming

// .proto.RuntimeOptions.PixelStreaming.WebRTC webRTC = 1;
inline bool RuntimeOptions_PixelStreaming::_internal_has_webrtc() const {
  return this != internal_default_instance() && _impl_.webrtc_ != nullptr;
}
inline bool RuntimeOptions_PixelStreaming::has_webrtc() const {
  return _internal_has_webrtc();
}
inline void RuntimeOptions_PixelStreaming::clear_webrtc() {
  if (GetArenaForAllocation() == nullptr && _impl_.webrtc_ != nullptr) {
    delete _impl_.webrtc_;
  }
  _impl_.webrtc_ = nullptr;
}
inline const ::proto::RuntimeOptions_PixelStreaming_WebRTC& RuntimeOptions_PixelStreaming::_internal_webrtc() const {
  const ::proto::RuntimeOptions_PixelStreaming_WebRTC* p = _impl_.webrtc_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RuntimeOptions_PixelStreaming_WebRTC&>(
      ::proto::_RuntimeOptions_PixelStreaming_WebRTC_default_instance_);
}
inline const ::proto::RuntimeOptions_PixelStreaming_WebRTC& RuntimeOptions_PixelStreaming::webrtc() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.PixelStreaming.webRTC)
  return _internal_webrtc();
}
inline void RuntimeOptions_PixelStreaming::unsafe_arena_set_allocated_webrtc(
    ::proto::RuntimeOptions_PixelStreaming_WebRTC* webrtc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.webrtc_);
  }
  _impl_.webrtc_ = webrtc;
  if (webrtc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RuntimeOptions.PixelStreaming.webRTC)
}
inline ::proto::RuntimeOptions_PixelStreaming_WebRTC* RuntimeOptions_PixelStreaming::release_webrtc() {
  
  ::proto::RuntimeOptions_PixelStreaming_WebRTC* temp = _impl_.webrtc_;
  _impl_.webrtc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RuntimeOptions_PixelStreaming_WebRTC* RuntimeOptions_PixelStreaming::unsafe_arena_release_webrtc() {
  // @@protoc_insertion_point(field_release:proto.RuntimeOptions.PixelStreaming.webRTC)
  
  ::proto::RuntimeOptions_PixelStreaming_WebRTC* temp = _impl_.webrtc_;
  _impl_.webrtc_ = nullptr;
  return temp;
}
inline ::proto::RuntimeOptions_PixelStreaming_WebRTC* RuntimeOptions_PixelStreaming::_internal_mutable_webrtc() {
  
  if (_impl_.webrtc_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RuntimeOptions_PixelStreaming_WebRTC>(GetArenaForAllocation());
    _impl_.webrtc_ = p;
  }
  return _impl_.webrtc_;
}
inline ::proto::RuntimeOptions_PixelStreaming_WebRTC* RuntimeOptions_PixelStreaming::mutable_webrtc() {
  ::proto::RuntimeOptions_PixelStreaming_WebRTC* _msg = _internal_mutable_webrtc();
  // @@protoc_insertion_point(field_mutable:proto.RuntimeOptions.PixelStreaming.webRTC)
  return _msg;
}
inline void RuntimeOptions_PixelStreaming::set_allocated_webrtc(::proto::RuntimeOptions_PixelStreaming_WebRTC* webrtc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.webrtc_;
  }
  if (webrtc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(webrtc);
    if (message_arena != submessage_arena) {
      webrtc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, webrtc, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.webrtc_ = webrtc;
  // @@protoc_insertion_point(field_set_allocated:proto.RuntimeOptions.PixelStreaming.webRTC)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RuntimeOptions_VolumeMounts

// string name = 1;
inline void RuntimeOptions_VolumeMounts::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RuntimeOptions_VolumeMounts::name() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.VolumeMounts.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RuntimeOptions_VolumeMounts::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RuntimeOptions.VolumeMounts.name)
}
inline std::string* RuntimeOptions_VolumeMounts::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:proto.RuntimeOptions.VolumeMounts.name)
  return _s;
}
inline const std::string& RuntimeOptions_VolumeMounts::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RuntimeOptions_VolumeMounts::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RuntimeOptions_VolumeMounts::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RuntimeOptions_VolumeMounts::release_name() {
  // @@protoc_insertion_point(field_release:proto.RuntimeOptions.VolumeMounts.name)
  return _impl_.name_.Release();
}
inline void RuntimeOptions_VolumeMounts::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RuntimeOptions.VolumeMounts.name)
}

// string mountPath = 2;
inline void RuntimeOptions_VolumeMounts::clear_mountpath() {
  _impl_.mountpath_.ClearToEmpty();
}
inline const std::string& RuntimeOptions_VolumeMounts::mountpath() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.VolumeMounts.mountPath)
  return _internal_mountpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RuntimeOptions_VolumeMounts::set_mountpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mountpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.RuntimeOptions.VolumeMounts.mountPath)
}
inline std::string* RuntimeOptions_VolumeMounts::mutable_mountpath() {
  std::string* _s = _internal_mutable_mountpath();
  // @@protoc_insertion_point(field_mutable:proto.RuntimeOptions.VolumeMounts.mountPath)
  return _s;
}
inline const std::string& RuntimeOptions_VolumeMounts::_internal_mountpath() const {
  return _impl_.mountpath_.Get();
}
inline void RuntimeOptions_VolumeMounts::_internal_set_mountpath(const std::string& value) {
  
  _impl_.mountpath_.Set(value, GetArenaForAllocation());
}
inline std::string* RuntimeOptions_VolumeMounts::_internal_mutable_mountpath() {
  
  return _impl_.mountpath_.Mutable(GetArenaForAllocation());
}
inline std::string* RuntimeOptions_VolumeMounts::release_mountpath() {
  // @@protoc_insertion_point(field_release:proto.RuntimeOptions.VolumeMounts.mountPath)
  return _impl_.mountpath_.Release();
}
inline void RuntimeOptions_VolumeMounts::set_allocated_mountpath(std::string* mountpath) {
  if (mountpath != nullptr) {
    
  } else {
    
  }
  _impl_.mountpath_.SetAllocated(mountpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mountpath_.IsDefault()) {
    _impl_.mountpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.RuntimeOptions.VolumeMounts.mountPath)
}

// bool readOnly = 3;
inline void RuntimeOptions_VolumeMounts::clear_readonly() {
  _impl_.readonly_ = false;
}
inline bool RuntimeOptions_VolumeMounts::_internal_readonly() const {
  return _impl_.readonly_;
}
inline bool RuntimeOptions_VolumeMounts::readonly() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.VolumeMounts.readOnly)
  return _internal_readonly();
}
inline void RuntimeOptions_VolumeMounts::_internal_set_readonly(bool value) {
  
  _impl_.readonly_ = value;
}
inline void RuntimeOptions_VolumeMounts::set_readonly(bool value) {
  _internal_set_readonly(value);
  // @@protoc_insertion_point(field_set:proto.RuntimeOptions.VolumeMounts.readOnly)
}

// -------------------------------------------------------------------

// RuntimeOptions

// .proto.RuntimeOptions.Resolution resolution = 1;
inline bool RuntimeOptions::_internal_has_resolution() const {
  return this != internal_default_instance() && _impl_.resolution_ != nullptr;
}
inline bool RuntimeOptions::has_resolution() const {
  return _internal_has_resolution();
}
inline void RuntimeOptions::clear_resolution() {
  if (GetArenaForAllocation() == nullptr && _impl_.resolution_ != nullptr) {
    delete _impl_.resolution_;
  }
  _impl_.resolution_ = nullptr;
}
inline const ::proto::RuntimeOptions_Resolution& RuntimeOptions::_internal_resolution() const {
  const ::proto::RuntimeOptions_Resolution* p = _impl_.resolution_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RuntimeOptions_Resolution&>(
      ::proto::_RuntimeOptions_Resolution_default_instance_);
}
inline const ::proto::RuntimeOptions_Resolution& RuntimeOptions::resolution() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.resolution)
  return _internal_resolution();
}
inline void RuntimeOptions::unsafe_arena_set_allocated_resolution(
    ::proto::RuntimeOptions_Resolution* resolution) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resolution_);
  }
  _impl_.resolution_ = resolution;
  if (resolution) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RuntimeOptions.resolution)
}
inline ::proto::RuntimeOptions_Resolution* RuntimeOptions::release_resolution() {
  
  ::proto::RuntimeOptions_Resolution* temp = _impl_.resolution_;
  _impl_.resolution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RuntimeOptions_Resolution* RuntimeOptions::unsafe_arena_release_resolution() {
  // @@protoc_insertion_point(field_release:proto.RuntimeOptions.resolution)
  
  ::proto::RuntimeOptions_Resolution* temp = _impl_.resolution_;
  _impl_.resolution_ = nullptr;
  return temp;
}
inline ::proto::RuntimeOptions_Resolution* RuntimeOptions::_internal_mutable_resolution() {
  
  if (_impl_.resolution_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RuntimeOptions_Resolution>(GetArenaForAllocation());
    _impl_.resolution_ = p;
  }
  return _impl_.resolution_;
}
inline ::proto::RuntimeOptions_Resolution* RuntimeOptions::mutable_resolution() {
  ::proto::RuntimeOptions_Resolution* _msg = _internal_mutable_resolution();
  // @@protoc_insertion_point(field_mutable:proto.RuntimeOptions.resolution)
  return _msg;
}
inline void RuntimeOptions::set_allocated_resolution(::proto::RuntimeOptions_Resolution* resolution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resolution_;
  }
  if (resolution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resolution);
    if (message_arena != submessage_arena) {
      resolution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolution, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resolution_ = resolution;
  // @@protoc_insertion_point(field_set_allocated:proto.RuntimeOptions.resolution)
}

// repeated string args = 2;
inline int RuntimeOptions::_internal_args_size() const {
  return _impl_.args_.size();
}
inline int RuntimeOptions::args_size() const {
  return _internal_args_size();
}
inline void RuntimeOptions::clear_args() {
  _impl_.args_.Clear();
}
inline std::string* RuntimeOptions::add_args() {
  std::string* _s = _internal_add_args();
  // @@protoc_insertion_point(field_add_mutable:proto.RuntimeOptions.args)
  return _s;
}
inline const std::string& RuntimeOptions::_internal_args(int index) const {
  return _impl_.args_.Get(index);
}
inline const std::string& RuntimeOptions::args(int index) const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.args)
  return _internal_args(index);
}
inline std::string* RuntimeOptions::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:proto.RuntimeOptions.args)
  return _impl_.args_.Mutable(index);
}
inline void RuntimeOptions::set_args(int index, const std::string& value) {
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:proto.RuntimeOptions.args)
}
inline void RuntimeOptions::set_args(int index, std::string&& value) {
  _impl_.args_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:proto.RuntimeOptions.args)
}
inline void RuntimeOptions::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.RuntimeOptions.args)
}
inline void RuntimeOptions::set_args(int index, const char* value, size_t size) {
  _impl_.args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.RuntimeOptions.args)
}
inline std::string* RuntimeOptions::_internal_add_args() {
  return _impl_.args_.Add();
}
inline void RuntimeOptions::add_args(const std::string& value) {
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.RuntimeOptions.args)
}
inline void RuntimeOptions::add_args(std::string&& value) {
  _impl_.args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:proto.RuntimeOptions.args)
}
inline void RuntimeOptions::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.RuntimeOptions.args)
}
inline void RuntimeOptions::add_args(const char* value, size_t size) {
  _impl_.args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.RuntimeOptions.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RuntimeOptions::args() const {
  // @@protoc_insertion_point(field_list:proto.RuntimeOptions.args)
  return _impl_.args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RuntimeOptions::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:proto.RuntimeOptions.args)
  return &_impl_.args_;
}

// map<string, string> environmentVariables = 3;
inline int RuntimeOptions::_internal_environmentvariables_size() const {
  return _impl_.environmentvariables_.size();
}
inline int RuntimeOptions::environmentvariables_size() const {
  return _internal_environmentvariables_size();
}
inline void RuntimeOptions::clear_environmentvariables() {
  _impl_.environmentvariables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RuntimeOptions::_internal_environmentvariables() const {
  return _impl_.environmentvariables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RuntimeOptions::environmentvariables() const {
  // @@protoc_insertion_point(field_map:proto.RuntimeOptions.environmentVariables)
  return _internal_environmentvariables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RuntimeOptions::_internal_mutable_environmentvariables() {
  return _impl_.environmentvariables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RuntimeOptions::mutable_environmentvariables() {
  // @@protoc_insertion_point(field_mutable_map:proto.RuntimeOptions.environmentVariables)
  return _internal_mutable_environmentvariables();
}

// repeated .proto.RuntimeOptions.VolumeMounts volumeMounts = 4;
inline int RuntimeOptions::_internal_volumemounts_size() const {
  return _impl_.volumemounts_.size();
}
inline int RuntimeOptions::volumemounts_size() const {
  return _internal_volumemounts_size();
}
inline void RuntimeOptions::clear_volumemounts() {
  _impl_.volumemounts_.Clear();
}
inline ::proto::RuntimeOptions_VolumeMounts* RuntimeOptions::mutable_volumemounts(int index) {
  // @@protoc_insertion_point(field_mutable:proto.RuntimeOptions.volumeMounts)
  return _impl_.volumemounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RuntimeOptions_VolumeMounts >*
RuntimeOptions::mutable_volumemounts() {
  // @@protoc_insertion_point(field_mutable_list:proto.RuntimeOptions.volumeMounts)
  return &_impl_.volumemounts_;
}
inline const ::proto::RuntimeOptions_VolumeMounts& RuntimeOptions::_internal_volumemounts(int index) const {
  return _impl_.volumemounts_.Get(index);
}
inline const ::proto::RuntimeOptions_VolumeMounts& RuntimeOptions::volumemounts(int index) const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.volumeMounts)
  return _internal_volumemounts(index);
}
inline ::proto::RuntimeOptions_VolumeMounts* RuntimeOptions::_internal_add_volumemounts() {
  return _impl_.volumemounts_.Add();
}
inline ::proto::RuntimeOptions_VolumeMounts* RuntimeOptions::add_volumemounts() {
  ::proto::RuntimeOptions_VolumeMounts* _add = _internal_add_volumemounts();
  // @@protoc_insertion_point(field_add:proto.RuntimeOptions.volumeMounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::RuntimeOptions_VolumeMounts >&
RuntimeOptions::volumemounts() const {
  // @@protoc_insertion_point(field_list:proto.RuntimeOptions.volumeMounts)
  return _impl_.volumemounts_;
}

// .proto.RuntimeOptions.PixelStreaming pixelStreaming = 5;
inline bool RuntimeOptions::_internal_has_pixelstreaming() const {
  return this != internal_default_instance() && _impl_.pixelstreaming_ != nullptr;
}
inline bool RuntimeOptions::has_pixelstreaming() const {
  return _internal_has_pixelstreaming();
}
inline void RuntimeOptions::clear_pixelstreaming() {
  if (GetArenaForAllocation() == nullptr && _impl_.pixelstreaming_ != nullptr) {
    delete _impl_.pixelstreaming_;
  }
  _impl_.pixelstreaming_ = nullptr;
}
inline const ::proto::RuntimeOptions_PixelStreaming& RuntimeOptions::_internal_pixelstreaming() const {
  const ::proto::RuntimeOptions_PixelStreaming* p = _impl_.pixelstreaming_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::RuntimeOptions_PixelStreaming&>(
      ::proto::_RuntimeOptions_PixelStreaming_default_instance_);
}
inline const ::proto::RuntimeOptions_PixelStreaming& RuntimeOptions::pixelstreaming() const {
  // @@protoc_insertion_point(field_get:proto.RuntimeOptions.pixelStreaming)
  return _internal_pixelstreaming();
}
inline void RuntimeOptions::unsafe_arena_set_allocated_pixelstreaming(
    ::proto::RuntimeOptions_PixelStreaming* pixelstreaming) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pixelstreaming_);
  }
  _impl_.pixelstreaming_ = pixelstreaming;
  if (pixelstreaming) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.RuntimeOptions.pixelStreaming)
}
inline ::proto::RuntimeOptions_PixelStreaming* RuntimeOptions::release_pixelstreaming() {
  
  ::proto::RuntimeOptions_PixelStreaming* temp = _impl_.pixelstreaming_;
  _impl_.pixelstreaming_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::RuntimeOptions_PixelStreaming* RuntimeOptions::unsafe_arena_release_pixelstreaming() {
  // @@protoc_insertion_point(field_release:proto.RuntimeOptions.pixelStreaming)
  
  ::proto::RuntimeOptions_PixelStreaming* temp = _impl_.pixelstreaming_;
  _impl_.pixelstreaming_ = nullptr;
  return temp;
}
inline ::proto::RuntimeOptions_PixelStreaming* RuntimeOptions::_internal_mutable_pixelstreaming() {
  
  if (_impl_.pixelstreaming_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::RuntimeOptions_PixelStreaming>(GetArenaForAllocation());
    _impl_.pixelstreaming_ = p;
  }
  return _impl_.pixelstreaming_;
}
inline ::proto::RuntimeOptions_PixelStreaming* RuntimeOptions::mutable_pixelstreaming() {
  ::proto::RuntimeOptions_PixelStreaming* _msg = _internal_mutable_pixelstreaming();
  // @@protoc_insertion_point(field_mutable:proto.RuntimeOptions.pixelStreaming)
  return _msg;
}
inline void RuntimeOptions::set_allocated_pixelstreaming(::proto::RuntimeOptions_PixelStreaming* pixelstreaming) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pixelstreaming_;
  }
  if (pixelstreaming) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pixelstreaming);
    if (message_arena != submessage_arena) {
      pixelstreaming = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixelstreaming, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pixelstreaming_ = pixelstreaming;
  // @@protoc_insertion_point(field_set_allocated:proto.RuntimeOptions.pixelStreaming)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_customisation_2eproto
